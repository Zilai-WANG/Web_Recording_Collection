<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recording — {{ session_name }}</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,300;9..40,500;9..40,700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0b0d11;
            --surface: #12151c;
            --border: #242938;
            --text: #e2e4ea;
            --text-dim: #7a7f92;
            --green: #22d67a;
            --green-dim: rgba(34, 214, 122, 0.12);
            --red: #f04e5e;
            --red-dim: rgba(240, 78, 94, 0.12);
            --amber: #f0a030;
            --amber-dim: rgba(240, 160, 48, 0.12);
            --font: 'DM Sans', -apple-system, sans-serif;
            --mono: 'JetBrains Mono', monospace;
        }

        body {
            font-family: var(--font);
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Radial glow behind card */
        body::before {
            content: '';
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, rgba(34, 214, 122, 0.06) 0%, transparent 70%);
            pointer-events: none;
        }

        .card {
            position: relative;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 44px 40px;
            width: 420px;
            max-width: 95vw;
            text-align: center;
        }

        .session-name {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-dim);
            margin-bottom: 6px;
        }

        .participant-name {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: -0.4px;
            margin-bottom: 32px;
        }

        /* Orb */
        .orb-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 28px;
        }

        .orb {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: var(--green-dim);
            border: 2px solid rgba(34, 214, 122, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.5s ease;
        }

        .orb svg {
            width: 40px;
            height: 40px;
            color: var(--green);
            transition: color 0.3s;
        }

        /* Pulse rings for recording state */
        .orb-container .ring {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 1.5px solid var(--green);
            opacity: 0;
            pointer-events: none;
        }

        .state-recording .ring {
            animation: pulse-ring 2.4s ease-out infinite;
        }

        .ring:nth-child(2) { animation-delay: 0.8s; }
        .ring:nth-child(3) { animation-delay: 1.6s; }

        @keyframes pulse-ring {
            0% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(1.8); opacity: 0; }
        }

        /* Level meter bars */
        .level-meter {
            display: flex;
            justify-content: center;
            gap: 3px;
            height: 32px;
            align-items: flex-end;
            margin-bottom: 24px;
        }

        .level-bar {
            width: 4px;
            border-radius: 2px;
            background: var(--green);
            opacity: 0.25;
            transition: height 0.08s ease, opacity 0.08s ease;
            height: 4px;
        }

        /* Status label */
        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 18px;
            border-radius: 24px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            transition: all 0.3s;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: background 0.3s;
        }

        /* States */
        .state-idle .orb { background: rgba(122, 127, 146, 0.1); border-color: rgba(122, 127, 146, 0.2); }
        .state-idle .orb svg { color: var(--text-dim); }
        .state-idle .status-pill { background: rgba(122, 127, 146, 0.1); color: var(--text-dim); }
        .state-idle .status-dot { background: var(--text-dim); }

        .state-recording .orb { background: var(--green-dim); border-color: rgba(34, 214, 122, 0.4); }
        .state-recording .orb svg { color: var(--green); }
        .state-recording .status-pill { background: var(--green-dim); color: var(--green); }
        .state-recording .status-dot { background: var(--green); animation: blink 1.5s infinite; }

        .state-error .orb { background: var(--red-dim); border-color: rgba(240, 78, 94, 0.3); }
        .state-error .orb svg { color: var(--red); }
        .state-error .status-pill { background: var(--red-dim); color: var(--red); }
        .state-error .status-dot { background: var(--red); }

        .state-reconnecting .orb { background: var(--amber-dim); border-color: rgba(240, 160, 48, 0.3); }
        .state-reconnecting .orb svg { color: var(--amber); }
        .state-reconnecting .status-pill { background: var(--amber-dim); color: var(--amber); }
        .state-reconnecting .status-dot { background: var(--amber); animation: blink 0.6s infinite; }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .status-info {
            font-size: 12px;
            color: var(--text-dim);
            font-family: var(--mono);
            margin-bottom: 32px;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 28px;
            border: none;
            border-radius: 10px;
            font-family: var(--font);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-start {
            background: var(--green);
            color: #0b0d11;
        }

        .btn-start:hover { filter: brightness(1.12); transform: translateY(-1px); }

        .btn-stop {
            background: var(--red);
            color: #fff;
        }

        .btn-stop:hover { filter: brightness(1.12); }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        .actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        /* Footer note */
        .note {
            margin-top: 28px;
            font-size: 12px;
            color: var(--text-dim);
            line-height: 1.6;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .note strong { color: var(--text); font-weight: 600; }
    </style>
</head>
<body>
    <div class="card" id="root">
        <div class="session-name">{{ session_name }}</div>
        <div class="participant-name">{{ participant_name }}</div>

        <div class="orb-container state-idle" id="orbContainer">
            <div class="ring"></div>
            <div class="ring"></div>
            <div class="ring"></div>
            <div class="orb">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                    <line x1="12" y1="19" x2="12" y2="23"/>
                </svg>
            </div>
        </div>

        <div class="level-meter" id="levelMeter">
            <!-- 16 bars -->
        </div>

        <div class="status-pill" id="statusPill">
            <span class="status-dot"></span>
            <span id="statusText">Ready</span>
        </div>

        <div class="status-info" id="statusInfo">&nbsp;</div>

        <div class="actions">
            <button class="btn btn-start" id="btnStart" onclick="startRecording()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10"/></svg>
                Start Recording
            </button>
            <button class="btn btn-stop" id="btnStop" onclick="stopRecording()" style="display:none">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><rect x="4" y="4" width="16" height="16" rx="2"/></svg>
                Stop
            </button>
        </div>

        <div class="note">
            <strong>Tip:</strong> Keep this tab open while on your Zoom call.
            Only your microphone audio is captured — not system audio or other participants.
        </div>
    </div>

    <script>
        // ── Config ──────────────────────────────────────────
        const TOKEN = "{{ token }}";
        const CHUNK_INTERVAL_MS = 2000;  // send a chunk every 2 seconds
        const BAR_COUNT = 16;
        const WS_URL = `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}/ws/audio/${TOKEN}`;

        // ── State ───────────────────────────────────────────
        let mediaStream = null;
        let audioContext = null;
        let analyser = null;
        let scriptProcessor = null;
        let ws = null;
        let isRecording = false;
        let chunkCount = 0;
        let startTime = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT = 5;

        // ── UI refs ─────────────────────────────────────────
        const orbContainer = document.getElementById('orbContainer');
        const statusText = document.getElementById('statusText');
        const statusInfo = document.getElementById('statusInfo');
        const btnStart = document.getElementById('btnStart');
        const btnStop = document.getElementById('btnStop');
        const levelMeter = document.getElementById('levelMeter');

        // Build level bars
        for (let i = 0; i < BAR_COUNT; i++) {
            const bar = document.createElement('div');
            bar.className = 'level-bar';
            levelMeter.appendChild(bar);
        }
        const bars = levelMeter.querySelectorAll('.level-bar');

        // ── UI state machine ────────────────────────────────
        function setState(state, info = '') {
            orbContainer.className = `orb-container state-${state}`;
            const labels = { idle: 'Ready', recording: 'Recording', error: 'Error', reconnecting: 'Reconnecting…' };
            statusText.textContent = labels[state] || state;
            statusInfo.textContent = info || '\u00a0';
        }

        function updateTimer() {
            if (!isRecording || !startTime) return;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const m = String(Math.floor(elapsed / 60)).padStart(2, '0');
            const s = String(elapsed % 60).padStart(2, '0');
            statusInfo.textContent = `${m}:${s}  ·  ${chunkCount} chunks uploaded`;
        }

        // ── Audio Level Visualization ───────────────────────
        function startLevelViz() {
            if (!analyser) return;
            const data = new Uint8Array(analyser.frequencyBinCount);

            function draw() {
                if (!isRecording) {
                    bars.forEach(b => { b.style.height = '4px'; b.style.opacity = '0.25'; });
                    return;
                }
                analyser.getByteFrequencyData(data);
                const step = Math.floor(data.length / BAR_COUNT);
                for (let i = 0; i < BAR_COUNT; i++) {
                    const val = data[i * step] / 255;
                    const h = Math.max(4, val * 32);
                    bars[i].style.height = h + 'px';
                    bars[i].style.opacity = Math.max(0.25, val).toFixed(2);
                }
                requestAnimationFrame(draw);
            }
            draw();
        }

        // ── WebSocket ───────────────────────────────────────
        function connectWS() {
            return new Promise((resolve, reject) => {
                ws = new WebSocket(WS_URL);
                ws.binaryType = 'arraybuffer';

                ws.onopen = () => {
                    reconnectAttempts = 0;
                    resolve();
                };

                ws.onmessage = (e) => {
                    // ACK from server
                    try {
                        const msg = JSON.parse(e.data);
                        if (msg.type === 'ack') {
                            chunkCount = msg.chunks;
                        }
                    } catch (_) {}
                };

                ws.onerror = (err) => {
                    console.error('WS error', err);
                    reject(err);
                };

                ws.onclose = () => {
                    if (isRecording) {
                        tryReconnect();
                    }
                };
            });
        }

        async function tryReconnect() {
            if (reconnectAttempts >= MAX_RECONNECT) {
                setState('error', 'Connection lost. Please reload the page.');
                stopRecording();
                return;
            }
            reconnectAttempts++;
            setState('reconnecting', `Attempt ${reconnectAttempts}/${MAX_RECONNECT}`);
            try {
                await new Promise(r => setTimeout(r, 1500 * reconnectAttempts));
                await connectWS();
                setState('recording');
            } catch {
                tryReconnect();
            }
        }

        // ── Recording ───────────────────────────────────────
        async function startRecording() {
            try {
                // 1. Get microphone
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 48000,
                        channelCount: 1,
                    }
                });

                // 2. Set up AudioContext for raw PCM + visualization
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
                const source = audioContext.createMediaStreamSource(mediaStream);

                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);

                // ScriptProcessor to get raw PCM chunks
                const bufferSize = 4096;
                scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);
                let pcmBuffer = [];

                scriptProcessor.onaudioprocess = (e) => {
                    if (!isRecording) return;
                    const float32 = e.inputBuffer.getChannelData(0);
                    // Convert Float32 → Int16 PCM
                    const int16 = new Int16Array(float32.length);
                    for (let i = 0; i < float32.length; i++) {
                        const s = Math.max(-1, Math.min(1, float32[i]));
                        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    pcmBuffer.push(int16.buffer);
                };

                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);

                // 3. Connect WebSocket
                await connectWS();

                // 4. Start sending chunks at interval
                isRecording = true;
                startTime = Date.now();
                chunkCount = 0;

                setState('recording');
                startLevelViz();
                btnStart.style.display = 'none';
                btnStop.style.display = 'inline-flex';

                // Chunk sender
                const sendInterval = setInterval(() => {
                    if (!isRecording) {
                        clearInterval(sendInterval);
                        return;
                    }
                    if (pcmBuffer.length === 0) return;
                    if (!ws || ws.readyState !== WebSocket.OPEN) return;

                    // Merge buffers
                    const totalLen = pcmBuffer.reduce((sum, buf) => sum + buf.byteLength, 0);
                    const merged = new Uint8Array(totalLen);
                    let offset = 0;
                    for (const buf of pcmBuffer) {
                        merged.set(new Uint8Array(buf), offset);
                        offset += buf.byteLength;
                    }
                    pcmBuffer = [];

                    ws.send(merged.buffer);
                    chunkCount++;
                    updateTimer();
                }, CHUNK_INTERVAL_MS);

                // Timer update
                setInterval(updateTimer, 1000);

            } catch (err) {
                console.error('Start error:', err);
                if (err.name === 'NotAllowedError') {
                    setState('error', 'Microphone permission denied. Please allow access and reload.');
                } else {
                    setState('error', err.message);
                }
            }
        }

        function stopRecording() {
            isRecording = false;

            if (scriptProcessor) { scriptProcessor.disconnect(); scriptProcessor = null; }
            if (audioContext) { audioContext.close(); audioContext = null; }
            if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
            if (ws && ws.readyState === WebSocket.OPEN) { ws.close(); }

            setState('idle', `Session ended · ${chunkCount} chunks saved`);
            btnStart.style.display = 'inline-flex';
            btnStart.disabled = true;
            btnStart.textContent = 'Session Ended';
            btnStop.style.display = 'none';
        }

        // Warn on tab close
        window.addEventListener('beforeunload', (e) => {
            if (isRecording) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>
</body>
</html>
